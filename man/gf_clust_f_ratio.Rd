% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gradientforest_ext.R
\name{gf_clust_f_ratio}
\alias{gf_clust_f_ratio}
\title{F-ratio over many clusterings}
\usage{
gf_clust_f_ratio(gf, gf_grid_sites, env_grid = gf$X, k_range, reps = 1,
  is_parallel = TRUE, pow = 0.25, gf_predict_args = list(),
  clara_args = list())
}
\arguments{
\item{gf}{a gf model. Currently only single GF model, not combinedGradientForest}

\item{gf_grid_sites}{data.frame, same number of rows as gf$Y. Columns are keys from env_grid that map each gf sample to a grid cell. These columns will be excluded from transformation.
Usually lat,lon or a grid id. See examples if rows are already aligned.}

\item{env_grid}{environmental data in original units. Must have columns with the same names as gf_grid_sites for matching grid cells to biological samples.}

\item{k_range}{integer vector, cluster values to fit}

\item{reps}{integer, number of fitting repetitions for each entry in k_range}

\item{pow}{compression power for extrapolation, between 0 (capping) and 1 (linear). For example, 0.5 giver square root, 0.25 gives 4th root.}

\item{gf_predict_args}{list of additional arguments to predict.gradientForest}

\item{parallel}{TRUE/FALSE Run in parallel. Assumes a foreach registerDo* backend has been defined.}
}
\value{
returns list containing a list of all clusterings as clara objects. Each clara object has been extended with an anova element from gf_anova().
The return list also contains a factor vector of the mvpart assignments to sample sites, generated by gf_mvpart.

TODO
}
\description{
This function ties together a number of helper functions
to get the f-ratio for a gf fit.
}
\details{
It takes a gf model, an environmental grid, and a set of parameters for passing down into
helper functions.

You get bace a long table of F-ratio scores for each k.
}
\examples{

if (requireNamespace("gradientForest", quietly = TRUE)) {
library(gradientForest) #required to attach extendedForest

cluster_tests <- 3:5

data(CoMLsimulation)
preds <- colnames(Xsimulation)
specs <- colnames(Ysimulation)
f1 <- gradientForest(data.frame(Ysimulation,Xsimulation), preds, specs[1:6], ntree=10)
f2 <- gradientForest(data.frame(Ysimulation,Xsimulation), preds, specs[1:6+6], ntree=10)
f12 <- combinedGradientForest(west=f1,east=f2)

env_grid <- f1$X
env_grid$site_id <- 1:nrow(env_grid)
gf_grid_sites <- data.frame(site_id = 1:nrow(f1$Y))
k_range <- 2:10
reps <- 1
is_parallel <- FALSE
pow <- 0.25
set.seed(1000)
test <- gf_clust_f_ratio(gf = f1, gf_grid_sites = gf_grid_sites, env_grid = env_grid, k_range = k_range, reps =  reps, is_parallel = is_parallel, pow = pow)
testthat::expect_named(test, c("mvpart", "clust_list"))

testthat::expect_equal(length(test$clust_list), length(k_range)*reps)

testthat::expect_true(all(sapply(test$clust_list, function(x){class(x) == c("clara", "partition")} )))
testthat::expect_equal(class(test$mvpart), c("factor") )
set.seed(1000)
test2 <- gf_clust_f_ratio(gf = f1, gf_grid_sites = gf_grid_sites, env_grid = env_grid, k_range = k_range, reps =  reps, is_parallel = is_parallel, pow = pow*0.5)
#testthat::expect_true(test$clust_list[[1]]$anova$f_ratio != test2$clust_list[[1]]$anova$f_ratio)

#Adjust clara fittings

test3 <- gf_clust_f_ratio(gf = f1, gf_grid_sites = gf_grid_sites, env_grid = env_grid, k_range = k_range, reps =  reps+2, is_parallel = is_parallel, pow = pow,
clara_args = list(samples = 20, sampsize = 50, trace = 0, rngR = TRUE, pamLike = TRUE, correct.d = TRUE))

#Extract f-ratios per k into long form
f_ratio_test <- do.call(rbind, lapply(test3$clust_list, function(clust){
  return(data.frame(k = clust$anova$cluster, f_ratio = clust$anova$f_ratio))
}))

plot(f_ratio_test)

}



}
