% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gradientforest_ext.R
\name{compress_extrap_z}
\alias{compress_extrap_z}
\title{Compression Function}
\usage{
compress_extrap_z(x, p, a, b)
}
\arguments{
\item{x}{numeric vector, all >= 0}

\item{p}{power, in range [0, 1]}

\item{a}{gradient of linear extrapolation}

\item{b}{cap value}
}
\value{
numeric vector of compressed values \eqn{b \le z(x) \le ax + b}{b <= z(x) <= ax + b}
}
\description{
The logic is:

We have two lines:
\deqn{y_{cap} = b}{y_cap = b}
\deqn{y_{ext} = ax + b}{y_ext = ax + b}

where we set \eqn{x = 0} to be the point where extrapolation begins, so \eqn{y_{cap} = y_{ext}} at \eqn{x = 0}, and
\eqn{b} is the capped value.

We want to define a third line, \eqn{z(x)}, st.

\deqn{y_{cap} \le z(x) \le y_{ext} \all x \ge 0}{y_cap <= z(x) <= y_ext AA x >= 0}

Two clear choices are sigmoid functions that asymptote, and power functions that do not asymptote.

Here I will apply a power function to allow compositional turnover to grow indefinitely.

Let \eqn{0 \le p \le 1}{0 <= p <= 1} be the power x is raised to. Then:

\deqn{z = (x + c)^p + d}

where \eqn{c,d} are constants.

\eqn{x+c} for \eqn{p} between 0 and 1 grows faster than linear when \eqn{x+c} is close to 0, but it is also convex and monotonically increasing.
Therefore choosing \eqn{c,d} st. \eqn{y_{cap}(x)}{y_cap} is tangent to \eqn{z(x)} at \eqn{x = 0} will satisfy
\eqn{y_{cap} \le z(x) \le y_{ext} \all x \ge 0}{y_cap <= z(x) <= y_ext AA x >= 0}.

At the tangent we know:

\deqn{x = 0}
\deqn{y_{ext}(0) = z(0)}{y_ext(0) = z(0)}
\deqn{y_{ext}'(0) = z'(0)}{y'_ext(0) = z'(0)}

\deqn{y_{ext}'(0) = z'(0)}{y'_ext(0) = z'(0)}
\deqn{a = p(x+c)^{p-1}}{a = p(x+c)^(p-1)}
\deqn{a = p(c)^{p-1} by x = 0}{a = p(c)^(p-1) by x = 0}
\deqn{c = \frac{a}{p}^\frac{1}{p-1}}{c = (a/p)^(1/(p-1))}

\deqn{y_{ext}(0) = z(0)}{y_ext(0) = z(0)}
\deqn{b = c^p + d}{b = c^p + d}
\deqn{d = b - c^p}{d = b - c^p}
\deqn{d = b - \frac{a}{p}^\frac{p}{p-1}}{d = b - (a/p)^(p/(p-1))}

therefore, to compress the extrapolation by power \eqn{p}, use:

\deqn{z(x) = (x + \frac{a}{p}^\frac{1}{p-1})^p + b - \frac{a}{p}^\frac{p}{p-1}}{z(x) = (x + (a/p)^(1/(p-1)))^p + b - (a/p)^(p/(p-1))}

When extrapolating into the negative domain, just take the negative of both y and x, then call this function, then negate x and y again.
}
\details{
Helper function to apply power compression to
GF predictions.

The compressed value lies between a linear extrapolation (ext)
and capping at the maximum known value (cap)
}
\examples{

a <- 1
p <- 0.25
b <- 1
x <- seq(0, 5, 0.1)

testthat::expect_true(all(rphildyerphd:::compress_extrap_z(x, p, a, b) <= a*x+b))
testthat::expect_true(all(rphildyerphd:::compress_extrap_z(x, p, a, b) >= b))

testthat::expect_error(rphildyerphd:::compress_extrap_z(x, p = 2, a, b), "p not less than or equal to 1")
testthat::expect_error(rphildyerphd:::compress_extrap_z(x, p, a = -1, b), "a not greater than 0")
testthat::expect_error(rphildyerphd:::compress_extrap_z(x, p, a = 0, b), "a not greater than 0")
testthat::expect_error(rphildyerphd:::compress_extrap_z(x, p = -1, a, b), "p not greater than or equal to 0")
testthat::expect_error(rphildyerphd:::compress_extrap_z(x = seq(-1, 1, 0.1), p, a, b), "Elements 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 of x >= 0 are not true")

z <- rphildyerphd:::compress_extrap_z(x, p, a, b)
pl_all <- data.frame(x = x, y = a*x+b, z = z, cap = b)
matplot(pl_all$x, pl_all[,c("y","z", "cap")])

}
